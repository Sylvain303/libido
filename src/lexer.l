/*
 * lexer for parsing external source for collecting snippet of code.
 */

%{
/* generated by bison */
#include "bash_parser.tab.h"

#include "buf_string.c"
#include "bash_keywords.h"

/* helper */
void p(char *what, char *val)
{
    if(what[0] == '<')
        printf("\033[31;1m<\033[0m%d:\033[32;1m%s\033[0m:%s\033[31;1m>\033[0m", yylineno, ++what, val);
    else
        printf("%d:\033[32;1m%s\033[0m:%s\n", yylineno, what, val);
}

#define FALSE 0
#define TRUE 1

#ifdef DEBUG
#  define DEBUG_p(fmt, val) p(fmt, val);
#  define RET(val) p(#val, yytext); return val
#  define RETC(fmt, val) p(fmt, yytext); return val
#  define RETB(val)      printf(#val ":%s\n", collected.str); return val
#  define RETNL          return '\n'
#else
#  define DEBUG_p(fmt, val) /* empty */
#  define RET(val)       return val
#  define RETC(fmt, val) return val
#  define RETB(val)      return val
#  define RETNL          return '\n'
#endif

/* See Makefile and ../test/lexer.bats */
#ifdef TEST_LEXER
/* redefine macros for testing */
#  undef RET
#  undef RETC
#  undef RETB
#  undef RETNL
#  define RET(val)       printf(#val":%s\n", yytext); return val
#  define RETC(fmt, val) printf("%c\n", val); return val
#  define RETB(val)      printf(#val ":%s\n", collected.str); return val
#  define RETNL          printf("\\n\n"); return '\n'
#endif

/* macro for changing start condition from bison */
#define CHANGE_IF(mode) if(mode ## _change) { \
                          printf(#mode " ENTER\n");\
                          BEGIN(mode);\
                          mode ## _change = FALSE;\
                        }
#define INT_CHANGER(name) int name ## _change = 0;

%}

    /* variable definition */
    StringBuf collected;

IDENTIFIER          [A-Za-z][^[\](){} \t=\n#]*
COMMENT             #
INDENT              ^[ \t]+
BASH_TEST           -(lt|le|gt|ge|eq|[a-z])
BASH_VAR            \$([0-9]+|{IDENTIFIER}|\$)
NUMBER              [0-9]+
BASH_PONCTUATION    [[\]*<>|!&]{1,2}|==|!=

%option   yylineno

/* exclusive start condition */
%x comment libido function_body code unparsed_code string
%%

<comment>libido:        BEGIN(libido); RET(LIBIDO);
<comment>\n             BEGIN(0); RETNL;
<comment>.              /* skip */;

<libido>depend          RET(DEPEND);
<libido>verbatim        RET(VERBATIM);
<libido>{IDENTIFIER}    RET(IDENTIFIER);
<libido>\n              BEGIN(0); RETNL;
<libido>[[:blank:]]+    ;
<libido>.               RETC("<l", yytext[0]);

<code>{COMMENT}.*       RET(COMMENT_LINE);
<code>.*                RET(CODE);
<code>\n                BEGIN(0); RETNL;

<string>\\\"        buffer_add(&collected, yytext);
<string>[^"]+       buffer_add(&collected, yytext);
<string>\"          buffer_add(&collected, yytext); BEGIN(0); RETB(STRING);

{INDENT}                BEGIN(code); RET(INDENT);
{COMMENT}               BEGIN(comment); RET(COMMENT);
{IDENTIFIER}            if(is_keyword(yytext)) { RET(BASH_KEYWORD); } else { RET(IDENTIFIER); }
{BASH_VAR}              RET(BASH_VAR);
{NUMBER}                RET(NUMBER);
\"                      collected.size = 0; buffer_add(&collected, yytext); BEGIN(string);
'[^']+'                 RET(STRING);
{BASH_PONCTUATION}      RET(BASH_PONCTUATION);
{BASH_TEST}             RET(BASH_PONCTUATION);
[ \t]+                  ;
\n                      ; RETNL;
.                       RETC("<c", yytext[0]);

%%

/* only useful for unitesting */
#ifdef TEST_LEXER
int main(int argc, char **argv) {
    int val;

    init_bash_keywords();
    /* test routine, will eat all token and print them to stdout,
     * via RET() preprocessor macro
     */
    while( val = yylex() )
        ;

    return 0;
}
#endif
