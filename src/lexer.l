/*
 * lexer for parsing external source for collecting snippet of code.
 */

%{
/* generated by bison */
#include "bash_parser.tab.h"

#include "buf_string.c"
#include "bash_keywords.h"

/* linked list */
#include "collected_lines.h"

/* helper */
void p(char *what, char *val)
{
    if(what[0] == '<')
        printf("\033[31;1m<\033[0m%d:\033[32;1m%s\033[0m:%s\033[31;1m>\033[0m", yylineno, ++what, val);
    else
        printf("%d:\033[32;1m%s\033[0m:%s\n", yylineno, what, val);
}

#ifndef TRUE
# define FALSE 0
# define TRUE 1
#endif

/* Collecting lines */
#define COLLECT()   lexer_current_line = add_new_line(&lines, lexer_current_line)
#define ADD(str)    buffer_add(lexer_current_line, str)

#ifdef DEBUG
#  define DEBUG_p(fmt, val) p(fmt, val);
#  define RET(val)          p(#val, yytext); ADD(yytext); return val
#  define RETC(fmt, val)    p(fmt, yytext); ADD(yytext); return val
#  define RETNL             ADD(yytext); return '\n'
#else
   /* NORMALÂ mode */
#  define DEBUG_p(fmt, val) /* empty */
#  define RET(val)          ADD(yytext); return val
#  define RETC(fmt, val)    ADD(yytext); return val
#  define RETNL             ADD(yytext); return '\n'
#endif

/* See Makefile and ../test/lexer.bats */
#ifdef TEST_LEXER
/* redefine macros for testing */
#  undef RET
#  undef RETC
#  undef RETNL
#  define RET(val)       printf(#val":%s\n", yytext); ADD(yytext); return val
#  define RETC(fmt, val) printf("%c\n", val); ADD(yytext); return val
#  define RETNL          printf("\\n\n"); ADD(yytext); return '\n'
#endif

/* macro for changing start condition from bison */
#define CHANGE_IF(mode) if(mode ## _change) { \
                          printf(#mode " ENTER\n");\
                          BEGIN(mode);\
                          mode ## _change = FALSE;\
                        }
#define INT_CHANGER(name) int name ## _change = 0;

%}

    /* variable definition */
    StringBuf *lexer_current_line;
    GSList *lines;

    /* declare intger boolean changer for strat conditions */
    INT_CHANGER(function_body);
    INT_CHANGER(unparsed_code);

IDENTIFIER          [A-Za-z][^[\](){} \t=\n#]*
COMMENT             #
INDENT              ^[ \t]+
BASH_TEST           -(lt|le|gt|ge|eq|[a-z])
BASH_VAR            \$([0-9]+|{IDENTIFIER}|\$)
NUMBER              [0-9]+
BASH_PONCTUATION    [[\]*<>|!&]{1,2}|==|!=

%option   yylineno

/* exclusive start condition */
%x comment libido function_body code unparsed_code string
%%
	    /* helpers, will change start condition from bison with ENTER(sc) */
	    CHANGE_IF(function_body);
	    CHANGE_IF(unparsed_code);

<comment>libido:        BEGIN(libido); RET(LIBIDO);
<comment>\n             BEGIN(0); COLLECT();
<comment>.              /* skip */ buffer_add(lexer_current_line, yytext);

<libido>depend          RET(DEPEND);
<libido>verbatim        RET(VERBATIM);
<libido>{IDENTIFIER}    RET(IDENTIFIER);
<libido>\n              BEGIN(0); COLLECT();
<libido>[[:blank:]]+    /* skip */ buffer_add(lexer_current_line, yytext);
<libido>.               RETC("<l", yytext[0]);

<code>{COMMENT}.*       RET(COMMENT_LINE);
<code>.*                RET(CODE);
<code>\n                BEGIN(0); COLLECT();

    /* WARNING ! specilat start condition can be reached only from the parser */
<function_body>{INDENT}         BEGIN(code); RET(INDENT);
<function_body>{COMMENT}[^\n]+  RET(COMMENT_LINE);
<function_body>\n               COLLECT();
<function_body>\}               BEGIN(0); buffer_add(lexer_current_line, yytext); return '}';

    /* to leave unparsed_code, the lexer must, match a "libido:" in a comment */
<unparsed_code>{COMMENT}[ \t]*libido:   BEGIN(libido); RET(LIBIDO);
<unparsed_code>.                        buffer_add(lexer_current_line, yytext);
<unparsed_code>\n                       COLLECT(); RET(UNPARSED);

    /* normal start conditions */
{INDENT}                BEGIN(code); RET(INDENT);
{COMMENT}               BEGIN(comment); RET(COMMENT);
{IDENTIFIER}            if(is_keyword(yytext)) { RET(BASH_KEYWORD); } else { RET(IDENTIFIER); }
[ \t]+                  /* eat spaces */ buffer_add(lexer_current_line, yytext);
\n                      COLLECT();
.                       RETC("<c", yytext[0]);

%%

void initilize_lexer() {
    lines = NULL;

    /* initialize a table with bash recognized keywors See bash_keywords.c */
    init_bash_keywords();

    /* for collecting lines 
     * BUF_SIZE is defined in collected_lines.h
     */
    lexer_current_line = StringBuf_create(BUF_SIZE);
}

/* only useful for unitesting */
#ifdef TEST_LEXER
int main(int argc, char **argv) {
    int val;
    GSList *p;

    initilize_lexer();

    if(argc >= 2 && strcmp(argv[1], "function_body") == 0) {
        function_body_change = 1;
    }

    if(argc >= 2 && strcmp(argv[1], "unparsed_code") == 0) {
        unparsed_code_change = 1;
    }

    /* test routine, will eat all token and print them to stdout,
     * via RET() preprocessor macros See lexer prologue.
     */
    while( val = yylex() )
        ;
    
    /* collector collect all the source for now */
    if(argc >= 2 && strcmp(argv[1], "--collected") == 0) {
        /* permit to do 
         * ./lexer < ../examples/libido/shell_lib.bash | sed -n '/^LEXER_END/,$ {/LEXER_END/ d; p}' \
         *  | diff - ../examples/libido/shell_lib.bash
         */
        printf("LEXER_END\n");
        p = lines;
        while(p) {
            printf("%s\n", ((StringBuf *)p->data)->str);
            p = p->next;
        }
    }

    return 0;
}
#endif
